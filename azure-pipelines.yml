# Copyright (c) .NET Foundation and Contributors
# See LICENSE file in the project root for full license information.

trigger:
  branches:
    include:
      - main
      - develop*
      - release-*
      - refs/tags/*
  paths:
    exclude:
      - .clang-format
      - .github_changelog_generator
      - .gitignore
      - .typo-ci.yml
      - build.ps1
      - CHANGELOG.md
      - CMakeSettings.json
      - CMakeSettings.SAMPLE.json
      - LICENSE.md
      - nf.props
      - nfcore.vssettings
      - README.md
      - README.zh-cn.md
      - RunCmd.bat
      - startocd.bat
      - .github/*
      - .devcontainer/*
      - .vscode/*
      - .vs/*
      - assets/*
      - config/*
      - install-scripts/*
      - VisualStudioDevelopment/*

pr:
  autoCancel: true
    
# add nf-tools repo to resources (for Azure Pipelines templates)
resources:
  repositories:
    - repository: templates
      type: github
      name: nanoframework/nf-tools
      endpoint: markusschweitzer
    - repository: esp32_idf
      type: github
      name: espressif/esp-idf
      endpoint: markusschweitzer
      ref: 'refs/tags/v5.1.4'
    - repository: mscorlib
      type: github
      name: nanoframework/CoreLibrary
      endpoint: markusschweitzer

jobs:
  ##############################
  - job: Check_Build_Options
    pool:
      vmImage: "windows-latest"

    variables:
      DOTNET_NOLOGO: true

    steps:
      - checkout: self
        fetchDepth: 1

      # get commit message
      - powershell: |

          # set default values
          echo "##vso[task.setvariable variable=RUN_MSCORLIB_TESTS;isOutput=true]false"

          if($env:StartReleaseCandidate -like "true")
          {
            # this is a release prep so NO build
            echo "##vso[task.setvariable variable=SKIP_BUILD;isOutput=true]true"
            
            Write-Host "##[command] Release preparation, skipping build."
          }
          else
          {
            # get commit details, if this is a PR
            if($env:System_PullRequest_PullRequestId -ne $null)
            {
              Write-Host "##[command] **This is a PR build**"

              $commit = Invoke-RestMethod -Uri "https://api.github.com/repos/markusschweitzer/nf-interpreter/commits/$(Build.SourceVersion)" -ContentType "application/json" -Method GET

              if( ($commit.commit.author.name -eq "nfbot") -and ($commit.commit.message -like "*[version update]*") )
              {
                echo "##vso[task.setvariable variable=SKIP_BUILD;isOutput=true]true"  
              }
              else
              {
                echo "##vso[task.setvariable variable=SKIP_BUILD;isOutput=true]false"  
              }

              # check if Unit Tests for mscorlib should be run
              if($commit.commit.message -like "*[run mscorlib tests]*")
              {
                echo "##vso[task.setvariable variable=RUN_MSCORLIB_TESTS;isOutput=true]true"
              }

            }
            else
            {
              Write-Host "##[command] **build for other reasons**"

              echo "##vso[task.setvariable variable=SKIP_BUILD;isOutput=true]false"
            }
          }

        name: BuildOptions
        displayName: Get build options

      # check what changed
      - powershell: |
              echo "##vso[task.setvariable variable=BUILD_CHIBIOS;isOutput=true]false"  
              echo "##vso[task.setvariable variable=BUILD_FREERTOS;isOutput=true]false"  
              echo "##vso[task.setvariable variable=BUILD_ESP32;isOutput=true]true"  
              echo "##vso[task.setvariable variable=BUILD_TI;isOutput=true]false"
              echo "##vso[task.setvariable variable=BUILD_AZURERTOS;isOutput=true]false"
              echo "##vso[task.setvariable variable=BUILD_WIN32;isOutput=true]false"  
              echo "##vso[task.setvariable variable=BUILD_NANOCLR_CLI;isOutput=true]false"  
              echo "##vso[task.setvariable variable=BUILD_ALL;isOutput=true]false"  
        name: TargetsToBuild
        displayName: Get targets to build

      - task: DotNetCoreCLI@2
        condition: eq( variables['StartReleaseCandidate'], true )
        displayName: Install NBGV tool
        inputs:
          command: custom
          custom: tool
          arguments: install -g nbgv

      - powershell: |

          # compute authorization header in format "AUTHORIZATION: basic 'encoded token'"
          # 'encoded token' is the Base64 of the string "nfbot:personal-token"
          $auth = "basic $([System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("nfbot:$(GitHubToken)")))"

          cd "$env:Agent_TempDirectory" > $null

          git init "$env:Agent_TempDirectory\repo"
          cd repo > $null
          git remote add origin "$env:Build_Repository_Uri"
          git config --global gc.auto 0
          git config --global user.name nfbot
          git config --global user.email nanoframework@outlook.com
          git config --global core.autocrlf true
          git -c http.extraheader="AUTHORIZATION: $auth" fetch --progress origin

          git checkout develop

          # prepare release and capture output
          $release = nbgv prepare-release

          # push all changes to github
          git -c http.extraheader="AUTHORIZATION: $auth" push --all origin

          # get release branch name
          $branch = $release.Split(' ')[0]

          # start PR for release
          $prRequestBody = @{title="Release $branch";body="";head="$branch";base="main"} | ConvertTo-Json
          $githubApiEndpoint = "https://api.github.com/repos/$env:Build_Repository_Name/pulls"
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

          $headers = @{}
          $headers.Add("Authorization","$auth")
          $headers.Add("Accept","application/vnd.github.symmetra-preview+json")

          try 
          {
              $result = Invoke-RestMethod -Method Post -UserAgent [Microsoft.PowerShell.Commands.PSUserAgent]::InternetExplorer -Uri  $githubApiEndpoint -Header $headers -ContentType "application/json" -Body $prRequestBody
              'Started PR for new release...' | Write-Host -NoNewline
              '##[error] OK' | Write-Host -ForegroundColor Green
          }
          catch 
          {
              $result = $_.Exception.Response.GetResponseStream()
              $reader = New-Object System.IO.StreamReader($result)
              $reader.BaseStream.Position = 0
              $reader.DiscardBufferedData()
              $responseBody = $reader.ReadToEnd();

              "##[error] Error starting PR: $responseBody" | Write-Host -ForegroundColor Red
          }

        condition: eq( variables['StartReleaseCandidate'], true )
        displayName: NBGV prepare release

  ##############################
  - job: Check_Code_Style
    condition: >-
      and(
        ne(dependencies.Check_Build_Options.outputs['BuildOptions.SKIP_BUILD'], true),
        or(
          eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_ALL'], true),
          eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_CHIBIOS'], true),
          eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_ESP32'], true),
          eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_FREERTOS'], true),
          eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_TI'], true),
          eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_AZURERTOS'], true),
          eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_WIN32'], true)
        )
      )

    dependsOn:
      - Check_Build_Options

    pool:
      vmImage: "windows-latest"

    steps:
      - checkout: self
        fetchDepth: 1
        condition: ne(variables['System.PullRequest.PullRequestId'], '')

      - template: azure-pipelines-templates/download-install-llvm.yml
      - template: azure-pipelines-templates/check-code-style.yml

  #################
  # ESP32 targets
  - job: Build_ESP32_targets
    condition: >-
      or(
        and(
          succeeded('Check_Code_Style'),
          ne( dependencies.Check_Build_Options.outputs['BuildOptions.SKIP_BUILD'], true ),
          or(
            eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_ALL'], true),
            eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_ESP32'], true)
          )
        ),
        and(
          eq(variables['Build.Reason'], 'Manual'),
          or(
            eq(variables['BUILD_ALL__'], 'true'),
            eq(variables['BUILD_ESP32__'], 'true')
          )
        )
      )

    dependsOn:
      - Check_Build_Options
      - Check_Code_Style

    pool:
      vmImage: "windows-latest"

    # there is only a single ESP32 target, but this is already config as a matrix to make it easy to add new ones
    strategy:
      matrix:
        ESP32_PSRAM_REV0:
          TargetBoard: ESP32
          TargetSeries: "esp32"
          BuildOptions:
          IDF_Target: esp32
          TargetName: ESP32
          PackageName: ESP32_PSRAM_REV0
          CMakePreset: ESP32_PSRAM_REV0

        ESP32_BLE_REV0:
          TargetBoard: ESP32
          TargetSeries: "esp32"
          BuildOptions:
          IDF_Target: esp32
          TargetName: ESP32
          PackageName: ESP32_BLE_REV0
          CMakePreset: ESP32_BLE_REV0

        ESP_WROVER_KIT:
          TargetBoard: ESP32
          TargetSeries: "esp32"
          BuildOptions:
          IDF_Target: esp32
          TargetName: ESP_WROVER_KIT
          PackageName: ESP_WROVER_KIT
          CMakePreset: ESP_WROVER_KIT

        ESP32_LILYGO:
          TargetBoard: ESP32
          TargetSeries: "esp32"
          BuildOptions:
          IDF_Target: esp32
          TargetName: ESP32_LILYGO
          PackageName: ESP32_LILYGO
          CMakePreset: ESP32_LILYGO

        FEATHER_S2:
          TargetBoard: ESP32_S2
          TargetSeries: "esp32_s2"
          BuildOptions:
          IDF_Target: esp32s2
          TargetName: FEATHER_S2
          PackageName: FEATHER_S2
          CMakePreset: FEATHER_S2

        ESP32_C3:
          TargetBoard: ESP32_C3
          TargetSeries: "esp32c3"
          BuildOptions:
          IDF_Target: esp32c3
          TargetName: ESP32_C3
          PackageName: ESP32_C3
          CMakePreset: ESP32_C3

        ESP32_C6_THREAD:
          TargetBoard: ESP32_C6
          TargetSeries: "esp32c6"
          BuildOptions:
          IDF_Target: esp32c6
          TargetName: ESP32_C6_THREAD
          PackageName: ESP32_C6_THREAD
          CMakePreset: ESP32_C6_THREAD

        ESP32_H2_THREAD:
          TargetBoard: ESP32_H2
          TargetSeries: "esp32h2"
          BuildOptions:
          IDF_Target: esp32h2
          TargetName: ESP32_H2_THREAD
          PackageName: ESP32_H2_THREAD
          CMakePreset: ESP32_H2_THREAD

        ESP32_S3:
          TargetBoard: ESP32_S3
          TargetSeries: "esp32s3"
          BuildOptions:
          IDF_Target: esp32s3
          TargetName: ESP32_S3
          PackageName: ESP32_S3
          CMakePreset: ESP32_S3

        ESP32_S3_ALL:
          TargetBoard: ESP32_S3
          TargetSeries: "esp32s3"
          BuildOptions:
          IDF_Target: esp32s3
          TargetName: ESP32_S3_ALL
          PackageName: ESP32_S3_ALL
          CMakePreset: ESP32_S3_ALL

        ESP32_ETHERNET_KIT_1.2:
          TargetBoard: ESP32
          TargetSeries: "esp32"
          BuildOptions:
          IDF_Target: esp32
          TargetName: ESP32_ETHERNET_KIT_1.2
          PackageName: ESP32_ETHERNET_KIT_1.2
          CMakePreset: ESP32_ETHERNET_KIT_1.2

    variables:
      DOTNET_NOLOGO: true
      # creates a counter and assigns it to the revision variable
      REVISION: $[counter('ESP32_1_10_0_versioncounter', 0)]
      IDF_PATH: "D:/a/1/s/esp-idf"
      PIP_CACHE_DIR: $(Pipeline.Workspace)/.pip
      TargetPlatform: "esp32"

    steps:
      - checkout: self
      - checkout: esp32_idf
        fetchDepth: 1

      - template: azure-pipelines-templates/build-preparations.yml
        parameters:
          repoDirectory: '$(Build.SourcesDirectory)\nf-interpreter'
      - template: azure-pipelines-templates/nb-gitversioning.yml
        parameters:
          repoDirectory: '$(Build.SourcesDirectory)\nf-interpreter'
      - template: azure-pipelines-templates/download-install-esp32-build-components.yml
      - template: azure-pipelines-templates/download-install-ninja.yml
        parameters:
          repoDirectory: '$(Build.SourcesDirectory)\nf-interpreter'
      - template: azure-pipelines-templates/build-espressif-esp32-targets.yml

      - task: CopyFiles@2
        condition: succeeded()
        displayName: Copying bootloader
        inputs:
          sourceFolder: '$(Build.SourcesDirectory)\nf-interpreter\build\bootloader'
          Contents: |
            bootloader.bin
          TargetFolder: '$(Build.ArtifactStagingDirectory)\$(TargetPublishName)'
          flattenFolders: true
          ignoreMakeDirErrors: true

      - template: azure-pipelines-templates/copy-sdkconfig.yml
      - template: azure-pipelines-templates/pack-publish-artifacts.yml
        parameters:
          buildDirectory: '$(Build.SourcesDirectory)\nf-interpreter\build'
      - template: azure-pipelines-templates/publish-cloudsmith.yml
      - template: azure-pipelines-templates/publish-sdkconfig.yml

  #################
  # WIN32 executable
  - job: Build_WIN32_nanoCLR
    condition: >-
      or(
        and(
          succeeded('Check_Code_Style'),
          ne( dependencies.Check_Build_Options.outputs['BuildOptions.SKIP_BUILD'], true ),
          or(
            eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_ALL'], true),
            eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_WIN32'], true)
          )
        ),
        and(
          eq(variables['Build.Reason'], 'Manual'),
          or(
            eq(variables['BUILD_ALL__'], 'true'),
            eq(variables['BUILD_WINDOWS_NANOCLR__'], 'true')
          )
        )
      )

    dependsOn:
      - Check_Build_Options
      - Check_Code_Style

    pool:
      vmImage: "windows-latest"

    variables:
      - name: DOTNET_NOLOGO
        value: true
      # creates a counter and assigns it to the revision variable
      - name: REVISION
        value: $[counter('WIN32_1_10_0_versioncounter', 0)]

    steps:
      - template: azure-pipelines-templates/nb-gitversioning.yml

      - task: PowerShell@2
        displayName: Store package version
        inputs:
          targetType: "inline"
          script: |
            Write-Host "$("##vso[task.setvariable variable=WINCLR_PACKAGE_VERSION]")$(NBGV_VersionMajor).$(NBGV_VersionMinor).$(NBGV_BuildNumber).$(TARGET_BUILD_COUNTER)"
            Write-Host "$("##vso[task.setvariable variable=WINCLR_AssemblyInformationalVersion]")$(NBGV_VersionMajor).$(NBGV_VersionMinor).$(NBGV_BuildNumber).$(TARGET_BUILD_COUNTER)$(NBGV_BuildMetadataFragment)"

      - template: azure-pipelines-templates/install-nuget.yml@templates

      - task: DotNetCoreCLI@2
        displayName: Restore NuGet packages
        inputs:
          command: restore
          restoreArguments: "--locked-mode"
          verbosityRestore: minimal
          projects: targets\netcore\nanoCLR.sln
          feedsToUse: select
          includeNuGetOrg: true

      - task: VSBuild@1
        displayName: Build WIN32 EXE target
        inputs:
          solution: 'targets\win32\nanoCLR.sln'
          platform: "x86"
          maximumCpuCount: true
          msbuildArgs: "/p:PublicRelease=true"
          configuration: "Release"

      - task: VSBuild@1
        displayName: Build WIN DLL target
        inputs:
          solution: 'targets\netcore\nanoCLR.sln'
          platform: "Any CPU"
          maximumCpuCount: true
          msbuildArgs: "/p:PublicRelease=true"
          configuration: "Release"

      - task: CopyFiles@2
        condition: succeeded()
        displayName: Adding nanoCLR WIN32 to deployable artifacts
        inputs:
          sourceFolder: $(Build.SourcesDirectory)
          Contents: |
            **\nanoFramework.nanoCLR.exe
          TargetFolder: '$(Build.ArtifactStagingDirectory)\WIN32_nanoCLR'
          flattenFolders: true
          ignoreMakeDirErrors: true

      - task: CopyFiles@2
        condition: succeeded()
        displayName: Adding nanoCLR DLL to deployable artifacts
        inputs:
          sourceFolder: $(Build.SourcesDirectory)
          Contents: |
            **\nanoFramework.nanoCLR.dll
          TargetFolder: '$(Build.ArtifactStagingDirectory)\WIN_DLL_nanoCLR'
          flattenFolders: true
          ignoreMakeDirErrors: true

      # publish artifacts
      - task: PublishPipelineArtifact@1
        condition: succeeded()
        displayName: Publish deployables artifacts
        inputs:
          targetPath: "$(Build.ArtifactStagingDirectory)"
          artifactName: nanoclr_win32
          artifactType: pipeline
          
  #################
  # nanoCLR CLI tool
  - job: Build_nanoCLR_CLI
    condition: >-
      or(
        and(
          succeeded('Check_Code_Style'),
          ne(dependencies.Check_Build_Options.outputs['BuildOptions.SKIP_BUILD'], true),
          or(
            eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_ALL'], true),
            eq(dependencies.Check_Build_Options.outputs['TargetsToBuild.BUILD_NANOCLR_CLI'], true)
          )
        ),
        and(
          eq(variables['Build.Reason'], 'Manual'),
          or(
            eq(variables['BUILD_ALL__'], 'true'),
            eq(variables['BUILD_NANOCLR_CLI__'], 'true')
          )
        )
      )

    dependsOn:
      - Check_Build_Options
      - Check_Code_Style

    pool:
      vmImage: "windows-latest"

    variables:
      - name: DOTNET_NOLOGO
        value: true

    steps:
      - template: azure-pipelines-templates/nb-gitversioning.yml

      - template: azure-pipelines-templates/install-nuget.yml@templates

      - task: DotNetCoreCLI@2
        displayName: Restore NuGet packages
        inputs:
          command: restore
          verbosityRestore: minimal
          projects: targets\netcore\nanoCLR.sln
          feedsToUse: select
          includeNuGetOrg: true

      - task: VSBuild@1
        displayName: Build .NET tool
        condition: succeeded()
        inputs:
          solution: 'targets\netcore\nanoCLR.sln'
          platform: "Any CPU"
          maximumCpuCount: true
          msbuildArgs: "/p:PublicRelease=true"
          configuration: "Release"

      - task: DotNetCoreCLI@2
        displayName: Install Sign Client CLI
        condition: >-
          and(
            succeeded(),
            eq(variables['System.PullRequest.PullRequestId'], '')
          )
        inputs:
          command: custom
          custom: tool
          arguments: install --tool-path . sign --version 0.9.1-beta.23530.1

      - pwsh: |
          .\sign code azure-key-vault `
          "**/nanoFramework.nanoCLR.*" `
          --base-directory "$(Build.Repository.LocalPath)\build\bin\Release" `
          --file-list "$(Build.Repository.LocalPath)\config\filelist.txt" `
          --publisher-name ".NET nanoFramework" `
          --description "nanoFramework.nanoCLR.CLI" `
          --description-url "https://github.com/$env:Build_Repository_Name" `
          --azure-key-vault-tenant-id "$(SignTenantId)" `
          --azure-key-vault-client-id "$(SignClientId)" `
          --azure-key-vault-client-secret "$(SignClientSecret)" `
          --azure-key-vault-certificate "$(SignKeyVaultCertificate)" `
          --azure-key-vault-url "$(SignKeyVaultUrl)" `
          --timestamp-url http://timestamp.digicert.com
        displayName: Sign nanoCLR assemblies
        continueOnError: true
        condition: >-
          and(
            succeeded(),
            eq(variables['System.PullRequest.PullRequestId'], '')
          )

      - task: MSBuild@1
        condition: succeeded()
        displayName: Pack nanoCLR CLI
        inputs:
          solution: 'targets\netcore\nanoFramework.nanoCLR.CLI\nanoFramework.nanoCLR.CLI.csproj'
          platform: "Any CPU"
          msbuildArguments: "/p:PublicRelease=true /t:pack /p:PackageOutputPath=$(Build.ArtifactStagingDirectory) "
          configuration: "Release"
          maximumCpuCount: true

      - pwsh: |
          .\sign code azure-key-vault `
          "**/*.nupkg" `
          --base-directory "$(Build.ArtifactStagingDirectory)" `
          --file-list "$(Build.Repository.LocalPath)\config\filelist.txt" `
          --publisher-name ".NET nanoFramework" `
          --description "nanoFramework.nanoCLR.CLI NuGet" `
          --description-url "https://github.com/$env:Build_Repository_Name" `
          --azure-key-vault-tenant-id "$(SignTenantId)" `
          --azure-key-vault-client-id "$(SignClientId)" `
          --azure-key-vault-client-secret "$(SignClientSecret)" `
          --azure-key-vault-certificate "$(SignKeyVaultCertificate)" `
          --azure-key-vault-url "$(SignKeyVaultUrl)" `
          --timestamp-url http://timestamp.digicert.com
        displayName: Sign packages
        continueOnError: true
        condition: >-
          and(
            succeeded(),
            eq(variables['System.PullRequest.PullRequestId'], '')
          )

      - task: CopyFiles@2
        condition: succeeded()
        displayName: Copy nanoclr
        inputs:
          SourceFolder: '$(Build.Repository.LocalPath)\build\bin\Release'
          Contents: "nanoFramework.nanoCLR.dll"
          TargetFolder: "$(Build.ArtifactStagingDirectory)/nanoclr"

      - task: PublishPipelineArtifact@1
        condition: succeeded()
        displayName: Publish nanoclr
        inputs:
          targetPath: "$(Build.ArtifactStagingDirectory)/nanoclr"
          artifactName: nanoclr_cli
          artifactType: pipeline